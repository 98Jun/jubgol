SELECT *
FROM  STUDENT s , DEPARTMENT d 

SELECT student.NAME , student.STU_ID , department.DEPT_NAME 
FROM STUDENT  ,DEPARTMENT  
WHERE  student.DEPT_ID  =  department.DEPT_ID 

SELECT  student.STU_ID
FROM STUDENT , DEPARTMENT 
WHERE  student.DEPT_ID  = department.dept_id AND
student.YEAR  = 3  AND 
department.DEPT_NAME ='컴퓨터공학과'

SELECT s.STU_ID 
FROM STUDENT s ,DEPARTMENT d 
WHERE s.DEPT_ID  = d.DEPT_ID 


SELECT name, stu_id  -- 스튵필드에 YEAR이 3이거나 4 인 사람의 이름과아이디정보출력 
FROM STUDENT s 
WHERE  YEAR = 3 OR  YEAR = 4
ORDER BY 1 DESC , STU_ID  --정렬기준은 이름 내림차순

SELECT s.NAME ,d.DEPT_NAME 
FROM STUDENT s, DEPARTMENT d 
WHERE s.DEPT_ID  = d.DEPT_ID 

SELECT  *  --스튜던트에 김광식 씨 정보 다 출력
FROM STUDENT s 
WHERE NAME ='김광식'

SELECT s2.NAME ,s1.NAME  -- 스튣 1과 2 에 김광식씨 다 출력
FROM STUDENT s1, STUDENT s2
WHERE s1.ADDRESS = s2.ADDRESS AND s1.NAME ='김광식'
 
SELECT  * FROM  STUDENT s  --스튵 정보 다 출력


SELECT name,POSITION ,2012-YEAR_emp
FROM PROFESSOR 

SELECT name 이름,POSITION 직위, 2012-YEAR_emp 재직연수
FROM PROFESSOR 

SELECT *
FROM  STUDENT s 
WHERE  NAME LIKE '박%'


SELECT * 
FROM  STUDENT s 
WHERE RESIDENT_ID LIKE '%*2%' 
OR RESIDENT_ID  LIKE  '%*4%'

SELECT  *
FROM  STUDENT s 
WHERE RESIDENT_ID  LIKE '8%'

SELECT * FROM  STUDENT s 

SELECT name
FROM STUDENT s 
UNION  ALL  --ALL 입력하면 중복 삭제 안됨  그냥 UNION은 중복 삭제함 
SELECT NAME 
FROM PROFESSOR p 


SELECT s.RESIDENT_ID ,p.RESIDENT_ID 
FROM  STUDENT s ,PROFESSOR p 

SELECT s.RESIDENT_ID  -- 학생 주번
FROM STUDENT s 
UNION ALL 
SELECT p.RESIDENT_ID  -- 교수 주번 
FROM  PROFESSOR p 

SELECT s.STU_ID ,s.NAME , t.GRADE 
FROM STUDENT s ,DEPARTMENT d ,TAKES t 
WHERE s.DEPT_ID  = d.DEPT_ID  
AND  t.STU_ID =s.STU_ID  
AND dept_name = '컴퓨터공학과' 
AND grade = 'A+'

SELECT  * FROM  TAKES

SELECT STU_ID 
FROM STUDENT s ,DEPARTMENT d 
WHERE s.DEPT_ID =d.DEPT_ID  AND  DEPT_name = '컴퓨터공학과'
INTERSECT 
SELECT STU_ID 
FROM TAKES t 
WHERE grade = 'A+'

SELECT STU_ID 
FROM  STUDENT s ,DEPARTMENT d 
WHERE s.DEPT_ID =d.DEPT_ID AND  DEPT_name = '산업공학과'
MINUS 
SELECT STU_ID   FROM TAKES t 
WHERE grade = 'A+'

SELECT TITLE ,CREDIT ,YEAR ,semester
FROM COURSE c ,CLASS c1 
WHERE c.COURSE_ID =c1.COURSE_ID 

SELECT TITLE ,CREDIT ,YEAR ,SEMESTER 
FROM COURSE c LEFT OUTER JOIN CLASS c2 
USING (COURSE_ID)

SELECT TITLE ,CREDIT ,YEAR ,semester
FROM COURSE c ,CLASS c2 
WHERE c.COURSE_ID =c2.COURSE_ID (+)


SELECT TITLE ,CREDIT ,YEAR ,SEMESTER  
FROM COURSE c RIGHT OUTER JOIN CLASS c2 
USING (COURSE_ID)

SELECT  TITLE ,CREDIT ,YEAR ,semester
FROM  COURSE c ,CLASS c2 
WHERE c.COURSE_ID (+)=c2.COURSE_ID 

SELECT  COUNT(COMM)
FROM EMP e 

SELECT COUNT(*)
FROM EMP e 

SELECT COUNT(mgr)
FROM EMP e 

SELECT * FROM EMP e 

SELECT *
FROM  STUDENT s 

SELECT COUNT(DISTINCT DEPT_ID) -- student에서 DEPT_ID 의 값이 몇갠지 출력
FROM STUDENT s 

SELECT SUM(2022-YEAR_emp) --전체 교수들 재직 연수 합
FROM PROFESSOR p 

SELECT SUM(sal) -- EMP 모든 직원의 급여 합
FROM EMP e 

SELECT SUM(sal) -- ANAYST 직원의 급여 합
FROM EMP e 
WHERE JOB = 'ANALYST'

SELECT  SUM(SAL) -- 부서 이름이 RESEARCG인 직원들의 급여 합을 출력
FROM EMP e ,DEPT d 
WHERE e.DEPTNO =d.DEPTNO AND dname='RESEARCH'

SELECT * FROM EMP e 

SELECT DISTINCT job FROM EMP e WHERE JOB = 'CLERK'

SELECT DISTINCT job FROM EMP e WHERE JOB = 'SALEMAN'

SELECT DISTINCT job FROM EMP e WHERE JOB = 'MANAGER'

SELECT DISTINCT job FROM EMP e WHERE JOB = 'ANALYST'

SELECT DISTINCT sum(SAL)엄준식 FROM EMP e  WHERE JOB = 'PRESIDENT'


SELECT  AVG(2022-YEAR_emp) 평균연수
FROM PROFESSOR p 

SELECT MAX(sal) 최대급여 , MIN(SAL) 최소급여 ,AVG(SAL) 평균급여   
FROM EMP e ,DEPT d 
WHERE e.DEPTNO  = d.DEPTNO  AND  dname = 'ACCOUNTING'

SELECT e.ENAME ,SAL+COMM 직원들의보너스포함급여
FROM EMP e 

SELECT s.DEPT_ID ,COUNT(*)  
FROM  STUDENT s 
GROUP BY DEPT_ID

SELECT  JOB 직업 ,SUM(sal) 부서별연봉 --부서별 연봉 합 출력
FROM EMP e 
GROUP BY JOB

SELECT DEPT_name,COUNT(*) 
FROM 	STUDENT s ,DEPARTMENT d 
WHERE  s.DEPT_ID =d.DEPT_ID 
GROUP BY DEPT_name

SELECT dname 부서,COUNT(*)부서인원,AVG(sal) 평균연봉,MAX(SAL) 최고연봉,MIN(SAL)  최저연봉
FROM  EMP e ,DEPT d 
WHERE e.DEPTNO =d.DEPTNO 
GROUP BY dname


SELECT DEPT_name,COUNT(*),AVG(2022-YEAR_EMP),MAX(2022-YEAR_EMP)  
FROM PROFESSOR p ,DEPARTMENT d 
WHERE p.DEPT_ID =d.DEPT_ID 
GROUP BY DEPT_name
ORDER  BY DEPT_name 

SELECT DEPT_name 과이름,COUNT(*) 과인원,AVG(2012-YEAR_EMP)평균재직년수,MAX(2012-YEAR_EMP) 왕고
FROM  PROFESSOR p ,DEPARTMENT d 
WHERE p.DEPT_ID =d.DEPT_ID 
GROUP BY DEPT_name
HAVING AVG(2012-YEAR_EMP)>=10

SELECT dname 이름,COUNT(*) 인원,AVG(sal) 평균,MAX(sal) 최대,MIN(SAL) 체소  
FROM  EMP e ,DEPT d 
WHERE e.DEPTNO =d.DEPTNO 
GROUP BY dname
HAVING COUNT(*)>=5 

SELECT stu_id --널 가지고 있는 애들 검색하기 
FROM TAKES t 
WHERE GRADE IS NULL  

SELECT stu_id
FROM TAKES t 
WHERE GRADE <> 'A+'
--WHERE NOT GRADE = 'A+'
--WHERE GRADE != 'A+'

SELECT TITLE  --301호 강의실에 개설된 강좌의 과목명을 출력 
FROM COURSE c 
WHERE COURSE_ID 
IN 
(SELECT  DISTINCT COURSE_ID 
FROM CLASS c2 
WHERE classroom='301호')
	

SELECT DISTINCT title --위 코드와 같은 것 
FROM COURSE c1, CLASS c2
WHERE c1.COURSE_ID =c2.COURSE_ID AND 
classroom= '301호'
	

SELECT TITLE  --2학기에 개설되지 않은 과목명 검색
FROM COURSE c 
WHERE COURSE_ID  
NOT IN 
(SELECT COURSE_ID
FROM CLASS c2
WHERE YEAR=2012and SEMESTER=2)

SELECT *FROM TAKES t 

CREATE OR REPLACE VIEW V_TAKES AS --TAKES를 보안 한 V_TAKES
SELECT STU_ID, CLASS_ID FROM TAKES
-- 뒤에 with read only 를 적을 경우 읽기만 가능한 뷰생성	
	
CREATE OR REPLACE VIEW  cs_student AS -- STUDENT 를 카피한 cs_STUDENT
SELECT s.STU_ID ,s.RESIDENT_ID ,s.NAME ,s."YEAR" ,s.ADDRESS ,s.DEPT_ID 
FROM  STUDENT s ,DEPARTMENT d 
WHERE s.DEPT_ID =d.DEPT_ID AND d.DEPT_NAME ='컴퓨터공학과'

SELECT *
FROM V_TAKES vt 
WHERE STU_ID ='1292001'

INSERT INTO V_TAKES  -- V_TAKES 에 밑에 밸류를 넣는다
VALUES ('1292502','C101-01')

SELECT * FROM V_TAKES vt  --확인하면 들어가잇음

SELECT * FROM TAKES t --V_TAKES 에 넣은거 확인은 되나 값은 넣을 수 없음

DROP VIEW V_TAKES 

CREATE OR REPLACE VIEW V_TAKES AS --TAKES를 보안 한 V_TAKES
SELECT STU_ID, CLASS_ID FROM TAKES
WITH READ ONLY 

	
	
	

	


